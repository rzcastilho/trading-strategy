# Data Model: Strategy Registration and Validation UI

**Feature**: 004-strategy-ui
**Date**: 2026-02-08
**Phase**: 1 (Design & Contracts)

## Overview

This document defines the data entities, relationships, and state management for the Strategy UI feature. The feature extends the existing `strategies` table with user authentication, version locking, and metadata fields.

---

## Entity Relationship Diagram

```
┌──────────────────┐
│      users       │
│ (phx.gen.auth)   │
└────────┬─────────┘
         │ 1
         │
         │ has many
         │
         ▼ *
┌──────────────────────────────────┐
│         strategies               │
│─────────────────────────────────│
│ • id (uuid, PK)                  │
│ • user_id (uuid, FK → users)     │──┐
│ • name (string, indexed)         │  │
│ • description (text, nullable)   │  │
│ • format (yaml|toml)             │  │
│ • content (text, DSL definition) │  │
│ • trading_pair (string)          │  │
│ • timeframe (string)             │  │
│ • status (draft|active|inactive  │  │
│           |archived)             │  │
│ • version (integer, default: 1)  │  │
│ • lock_version (int, default: 1) │  │ NEW FIELDS
│ • metadata (jsonb, nullable)     │  │
│ • created_at (timestamp)         │  │
│ • updated_at (timestamp)         │  │
└──────────────────────────────────┘  │
         │ 1                           │
         │                             │
         │ has many                    │
         │                             │
         ▼ *                           │
┌──────────────────────────────────┐  │
│       indicators                 │  │
│ (existing, unchanged)            │  │
└──────────────────────────────────┘  │
                                      │
┌──────────────────────────────────┐  │
│        signals                   │  │
│ (existing, unchanged)            │  │
└──────────────────────────────────┘  │
                                      │
┌──────────────────────────────────┐  │
│    trading_sessions              │  │
│ (existing, unchanged)            │  │
└──────────────────────────────────┘  │
                                      │
┌──────────────────────────────────┐  │
│       positions                  │  │
│ (existing, unchanged)            │  │
└──────────────────────────────────┘  │
```

---

## Entities

### 1. User (NEW)

**Source**: Generated by `mix phx.gen.auth`

**Purpose**: Represents authenticated users who can create and manage strategies.

**Schema**:
```elixir
schema "users" do
  field :email, :string
  field :hashed_password, :string
  field :confirmed_at, :naive_datetime

  has_many :strategies, TradingStrategy.Strategies.Strategy

  timestamps()
end
```

**Validations**:
- `email`: required, unique, valid email format
- `password`: required (min 12 characters), hashed

**Relationships**:
- `has_many :strategies` - One user can own many strategies

**Notes**:
- Generated by `phx.gen.auth` with complete authentication system
- Includes password reset, confirmation tokens, session management
- Uses bcrypt for password hashing

---

### 2. Strategy (MODIFIED)

**Purpose**: Represents a complete trading strategy definition with DSL content, owned by a user.

**Schema Updates**:
```elixir
schema "strategies" do
  # Existing fields
  field :name, :string
  field :description, :string
  field :format, :string          # "yaml" | "toml"
  field :content, :string         # DSL definition
  field :trading_pair, :string
  field :timeframe, :string
  field :status, :string          # "draft" | "active" | "inactive" | "archived"
  field :version, :integer, default: 1

  # NEW fields for Feature 004
  field :lock_version, :integer, default: 1  # Optimistic locking
  field :metadata, :map                      # JSON metadata (form autosave, last validation, etc.)

  belongs_to :user, TradingStrategy.Accounts.User  # NEW relationship

  # Existing relationships (unchanged)
  has_many :indicators, TradingStrategy.Strategies.Indicator
  has_many :signals, TradingStrategy.Strategies.Signal
  has_many :trading_sessions, TradingStrategy.Backtesting.TradingSession
  has_many :positions, TradingStrategy.Orders.Position

  timestamps(type: :utc_datetime_usec)
end
```

**Field Details**:

| Field | Type | Constraints | Purpose |
|-------|------|-------------|---------|
| `id` | uuid | PK, auto | Unique identifier |
| `user_id` | uuid | FK, NOT NULL, indexed | Owner of strategy |
| `name` | string | NOT NULL, max 200 chars | Display name |
| `description` | text | nullable | User-provided description |
| `format` | string | NOT NULL, enum | DSL format ("yaml" or "toml") |
| `content` | text | NOT NULL | Raw DSL content |
| `trading_pair` | string | NOT NULL | e.g., "BTC/USD" |
| `timeframe` | string | NOT NULL | e.g., "1m", "5m", "1h", "1d" |
| `status` | string | NOT NULL, enum | Lifecycle state |
| `version` | integer | NOT NULL, default: 1 | Version number for audit trail |
| `lock_version` | integer | NOT NULL, default: 1 | Optimistic locking counter |
| `metadata` | jsonb | nullable | Flexible storage for UI state |
| `inserted_at` | timestamp | NOT NULL | Creation time |
| `updated_at` | timestamp | NOT NULL | Last modification time |

**Indexes**:
```sql
CREATE UNIQUE INDEX strategies_user_name_version_idx
  ON strategies (user_id, name, version);
CREATE INDEX strategies_user_id_idx ON strategies (user_id);
CREATE INDEX strategies_status_idx ON strategies (status);
CREATE INDEX strategies_trading_pair_idx ON strategies (trading_pair);
```

**Status Enum Values**:
- `"draft"`: Under development, can be freely edited
- `"active"`: Live for trading (backtesting/paper/live), cannot edit
- `"inactive"`: Previously active, now stopped, can edit (creates new version)
- `"archived"`: Soft-deleted, read-only

**Metadata Field Schema** (JSONB):
```json
{
  "last_validation_at": "2026-02-08T10:30:00Z",
  "validation_errors": [],
  "syntax_test_passed": true,
  "syntax_test_at": "2026-02-08T10:35:00Z",
  "form_autosave": {
    "saved_at": "2026-02-08T10:32:00Z",
    "field_states": {}
  },
  "ui_preferences": {
    "collapsed_sections": ["risk_management"]
  }
}
```

**Validations**:
```elixir
def changeset(strategy, attrs) do
  strategy
  |> cast(attrs, [
      :name, :description, :format, :content,
      :trading_pair, :timeframe, :status, :version,
      :user_id, :metadata
    ])
  |> validate_required([
      :name, :format, :content, :trading_pair,
      :timeframe, :status, :user_id
    ])
  |> validate_length(:name, min: 3, max: 200)
  |> validate_inclusion(:format, ["yaml", "toml"])
  |> validate_inclusion(:status, ["draft", "active", "inactive", "archived"])
  |> validate_inclusion(:timeframe, [
      "1m", "5m", "15m", "30m", "1h", "4h", "1d", "1w"
    ])
  |> validate_dsl_content()  # Existing DSL validator
  |> foreign_key_constraint(:user_id)
  |> unsafe_validate_unique([:user_id, :name, :version], TradingStrategy.Repo)
  |> unique_constraint([:user_id, :name, :version])
  |> optimistic_lock(:lock_version)
end
```

**State Transitions**:
```
draft → active        (requires: valid DSL, backtest results exist)
active → inactive     (allowed anytime)
inactive → active     (allowed anytime)
draft → archived      (allowed)
inactive → archived   (allowed)
active → archived     (BLOCKED - must deactivate first)

Editing rules:
- draft: Edit in-place (no version increment)
- inactive: Creates new version (version + 1)
- active: BLOCKED (show error)
- archived: BLOCKED (read-only)
```

---

## Validation Rules

### Client-Side (LiveView Real-Time)

Triggered on `phx-change` events:

```elixir
# In LiveView handle_event("validate", ...)
changeset = Strategies.change_strategy(%Strategy{}, params)
  |> Map.put(:action, :validate)
```

**Validations Run:**
1. **Presence**: name, format, content, trading_pair, timeframe
2. **Length**: name (3-200 chars), description (max 1000 chars)
3. **Format**: format in ["yaml", "toml"], timeframe in valid list
4. **Uniqueness**: name + version unique per user (debounced)
5. **DSL Syntax**: Parse and validate DSL content

**Error Display**: Real-time inline errors below each field.

### Server-Side (Final Validation)

Triggered on form submit:

```elixir
# In LiveView handle_event("save", ...)
case Strategies.create_strategy(params) do
  {:ok, strategy} -> # Success
  {:error, changeset} -> # Show errors
end
```

**Additional Validations:**
1. **Database Constraints**: Unique index enforcement (race condition safety)
2. **Foreign Keys**: user_id must exist
3. **Status Transitions**: Validate allowed state changes
4. **DSL Deep Validation**: Full indicator/condition/risk parameter checks

---

## Context Functions

### TradingStrategy.Strategies (MODIFIED)

**New Functions**:
```elixir
# Scoped to user
@spec list_strategies(User.t(), keyword()) :: [Strategy.t()]
def list_strategies(%User{id: user_id}, opts \\ [])

@spec get_strategy(binary(), User.t()) :: Strategy.t() | nil
def get_strategy(id, %User{id: user_id})

@spec create_strategy(map(), User.t()) :: {:ok, Strategy.t()} | {:error, Changeset.t()}
def create_strategy(attrs, %User{id: user_id})

@spec update_strategy(Strategy.t(), map(), User.t()) ::
  {:ok, Strategy.t()} | {:error, Changeset.t()}
def update_strategy(strategy, attrs, %User{id: user_id})

# Version management
@spec create_new_version(Strategy.t(), map()) ::
  {:ok, Strategy.t()} | {:error, Changeset.t()}
def create_new_version(strategy, attrs)

@spec get_strategy_versions(binary(), User.t()) :: [Strategy.t()]
def get_strategy_versions(strategy_name, user)

# Status management
@spec can_edit?(Strategy.t()) :: boolean()
def can_edit?(%Strategy{status: status}), do: status not in ["active", "archived"]

@spec can_activate?(Strategy.t()) :: {:ok, :allowed} | {:error, String.t()}
def can_activate?(strategy)

@spec activate_strategy(Strategy.t()) :: {:ok, Strategy.t()} | {:error, Changeset.t()}
def activate_strategy(strategy)

# Syntax testing (FR-015)
@spec test_strategy_syntax(String.t(), atom()) ::
  {:ok, parsed_strategy} | {:error, [String.t()]}
def test_strategy_syntax(content, format)
```

**Authorization Pattern**:
All functions that access strategies MUST verify ownership:
```elixir
def get_strategy(id, %User{id: user_id}) do
  Repo.one(from s in Strategy,
    where: s.id == ^id and s.user_id == ^user_id)
end
```

---

## LiveView State Management

### Parent LiveView State (e.g., StrategyLive.Form)

```elixir
%{
  current_user: %User{},           # From session
  strategy: %Strategy{} | nil,     # nil for new, struct for edit
  form: %Phoenix.HTML.Form{},      # Form struct from to_form(changeset)
  indicators: [%{}],               # State for indicator builder
  entry_conditions: [%{}],         # State for condition builder
  exit_conditions: [%{}],          # State for exit condition builder
  loading: boolean(),              # Show spinner
  errors: [String.t()],            # Global errors
  metadata: %{
    autosave_enabled: true,
    last_autosave: DateTime.t(),
    unsaved_changes: boolean()
  }
}
```

### LiveComponent State (e.g., IndicatorBuilderComponent)

```elixir
%{
  id: String.t(),                  # Component ID
  selected_indicators: [%{
    id: String.t(),                # Temporary ID for UI
    type: String.t(),              # "sma", "ema", "rsi", etc.
    params: %{},                   # Indicator parameters
    valid?: boolean()              # Validation status
  }]
}
```

**State Flow**:
1. User interacts with LiveComponent (add indicator)
2. Component updates local state
3. Component sends message to parent: `{:indicators_changed, indicators}`
4. Parent updates strategy changeset
5. Parent triggers validation
6. Validation results flow back to form display

---

## Database Migrations

### Migration 1: Add User Authentication

```elixir
# Generated by mix phx.gen.auth
defmodule TradingStrategy.Repo.Migrations.CreateUsersAuthTables do
  use Ecto.Migration

  def change do
    # Creates users, users_tokens tables
    # Full implementation generated by phx.gen.auth
  end
end
```

### Migration 2: Add User Association to Strategies

```elixir
defmodule TradingStrategy.Repo.Migrations.AddUserIdToStrategies do
  use Ecto.Migration

  def change do
    alter table(:strategies) do
      add :user_id, references(:users, on_delete: :delete_all, type: :binary_id),
          null: false
      add :lock_version, :integer, default: 1, null: false
      add :metadata, :map
    end

    create index(:strategies, [:user_id])

    # Update unique constraint to scope by user
    drop_if_exists unique_index(:strategies, [:name, :version])
    create unique_index(:strategies, [:user_id, :name, :version])
  end
end
```

**Migration Notes**:
- Run after generating auth system
- Requires backfill for `user_id` if existing strategies
- `on_delete: :delete_all` ensures strategies deleted with user (GDPR compliance)

---

## Query Performance Considerations

### Expected Load
- Per user: 10-100 strategies (typical)
- Power users: 100-500 strategies
- UI displays: 50 strategies per page (pagination)

### Indexes Required
```sql
-- User ownership (already defined above)
CREATE INDEX strategies_user_id_idx ON strategies (user_id);

-- Status filtering
CREATE INDEX strategies_status_idx ON strategies (status);

-- Uniqueness enforcement
CREATE UNIQUE INDEX strategies_user_name_version_idx
  ON strategies (user_id, name, version);

-- Sorting by creation date
-- (already exists: timestamps automatically indexed by Ecto)
```

### Query Optimization Patterns
```elixir
# Use pagination for list views
def list_strategies(user, opts) do
  query = from s in Strategy,
    where: s.user_id == ^user.id,
    order_by: [desc: s.inserted_at],
    limit: ^(opts[:limit] || 50),
    offset: ^(opts[:offset] || 0)

  Repo.all(query)
end

# Preload associations only when needed
def get_strategy_with_indicators(id, user) do
  from(s in Strategy,
    where: s.id == ^id and s.user_id == ^user.id,
    preload: [:indicators])
  |> Repo.one()
end

# Use select for list views (don't load full DSL content)
def list_strategies_summary(user) do
  from(s in Strategy,
    where: s.user_id == ^user.id,
    select: %{
      id: s.id,
      name: s.name,
      status: s.status,
      version: s.version,
      trading_pair: s.trading_pair,
      updated_at: s.updated_at
    })
  |> Repo.all()
end
```

---

## Data Integrity Guarantees

### Database Level
1. **Foreign Key Constraints**: `user_id` references `users(id)`
2. **Unique Constraints**: `(user_id, name, version)` uniqueness
3. **Not Null Constraints**: Required fields enforced
4. **Check Constraints** (optional future enhancement):
   ```sql
   ALTER TABLE strategies ADD CONSTRAINT status_valid
     CHECK (status IN ('draft', 'active', 'inactive', 'archived'));
   ```

### Application Level
1. **Optimistic Locking**: Prevents concurrent update conflicts
2. **DSL Validation**: Ensures content is parseable and valid
3. **Authorization**: User can only access their own strategies
4. **Status Transition Validation**: Prevents invalid state changes

---

## Testing Considerations

### Unit Tests
- Strategy changeset validations
- Status transition logic
- User scoping queries
- Version conflict handling

### Integration Tests
- Create strategy end-to-end
- Update strategy with version conflict
- Delete strategy (cascade to indicators, signals)
- Activate strategy with missing backtest results (should fail)

### Property-Based Tests
- Uniqueness validation with concurrent inserts
- Optimistic locking under contention

---

## Summary

**Key Changes to Existing Schema**:
1. Add `user_id` foreign key
2. Add `lock_version` for optimistic locking
3. Add `metadata` JSONB field for flexible storage
4. Update unique constraint to scope by user

**New Entities**:
- `User` (from phx.gen.auth)

**Context Updates**:
- All functions scoped by user
- Version conflict detection
- Status transition guards
- Syntax testing function

**Data Integrity**:
- Database constraints + application validations
- Optimistic locking prevents conflicts
- User authorization prevents unauthorized access
